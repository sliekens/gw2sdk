using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

namespace GuildWars2.Tests.Generators;

// Generates property metadata for all Data Transfer Object types so tests can avoid unsupported reflection APIs under Native AOT.
[Generator]
internal sealed class DtPropertyMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterSourceOutput(context.CompilationProvider, static (spc, compilation) => Execute(compilation, spc));
    }

    private static void Execute(Compilation compilation, SourceProductionContext context)
    {
        IAssemblySymbol? sdk = compilation.SourceModule.ReferencedAssemblySymbols.FirstOrDefault(a => string.Equals(a.Name, "GuildWars2", StringComparison.Ordinal));
        if (sdk is null)
        {
            EmitPlaceholder(context);
            return;
        }

        List<PropertyMetadata> properties = [];
        Enumerate(sdk.GlobalNamespace, properties);

        StringBuilder builder = new();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("namespace GuildWars2.Tests.Common;");
        builder.AppendLine();
        builder.AppendLine("public partial class AssemblyFixture");
        builder.AppendLine("{");
        builder.AppendLine("    public readonly struct DtProperty");
        builder.AppendLine("    {");
        builder.AppendLine("        public DtProperty(string declaringType, string name, bool hasSetter, bool isInitOnly, bool isObsolete, bool hasRequiredMemberAttribute, bool isCollection, bool isImmutableCollection, bool isPrimaryConstructorProperty)");
        builder.AppendLine("        {");
        builder.AppendLine("            DeclaringType = declaringType;\n            Name = name;\n            HasSetter = hasSetter;\n            IsInitOnly = isInitOnly;\n            IsObsolete = isObsolete;\n            HasRequiredMemberAttribute = hasRequiredMemberAttribute;\n            IsCollection = isCollection;\n            IsImmutableCollection = isImmutableCollection;\n            IsPrimaryConstructorProperty = isPrimaryConstructorProperty;");
        builder.AppendLine("        }");
        builder.AppendLine("        public string DeclaringType { get; }");
        builder.AppendLine("        public string Name { get; }");
        builder.AppendLine("        public bool HasSetter { get; }");
        builder.AppendLine("        public bool IsInitOnly { get; }");
        builder.AppendLine("        public bool IsObsolete { get; }");
        builder.AppendLine("        public bool HasRequiredMemberAttribute { get; }");
        builder.AppendLine("        public bool IsCollection { get; }");
        builder.AppendLine("        public bool IsImmutableCollection { get; }");
        builder.AppendLine("        public bool IsPrimaryConstructorProperty { get; }");
        builder.AppendLine("    }");
        builder.AppendLine();
        builder.AppendLine("    public IEnumerable<DtProperty> DataTransferObjectProperties { get; } = new DtProperty[]");
        builder.AppendLine("    {");
        bool first = true;
        foreach (PropertyMetadata p in properties.OrderBy(p => p.DeclaringType).ThenBy(p => p.Name))
        {
            if (!first)
            {
                builder.AppendLine(",");
            }
            builder.Append("        new DtProperty(\"" + p.DeclaringType + "\", \"" + p.Name + "\", hasSetter: " + (p.HasSetter ? "true" : "false") + ", isInitOnly: " + (p.IsInitOnly ? "true" : "false") + ", isObsolete: " + (p.IsObsolete ? "true" : "false") + ", hasRequiredMemberAttribute: " + (p.HasRequiredMemberAttribute ? "true" : "false") + ", isCollection: " + (p.IsCollection ? "true" : "false") + ", isImmutableCollection: " + (p.IsImmutableCollection ? "true" : "false") + ", isPrimaryConstructorProperty: " + (p.IsPrimaryConstructorProperty ? "true" : "false") + ")");
            first = false;
        }
        builder.AppendLine();
        builder.AppendLine("    }; ");
        builder.AppendLine("}");
        context.AddSource("AssemblyFixture.DtPropertyMetadata.g.cs", builder.ToString());
    }

    private static void Enumerate(INamespaceSymbol scope, List<PropertyMetadata> properties)
    {
        foreach (ISymbol member in scope.GetMembers())
        {
            if (member is INamespaceSymbol ns)
            {
                Enumerate(ns, properties);
            }
            else if (member is INamedTypeSymbol type && type.TypeKind == TypeKind.Class && type.IsRecord)
            {
                string declaringType = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty);

                // Collect primary constructor parameter names
                HashSet<string> primaryCtorParams = GetPrimaryConstructorParameterNames(type);

                foreach (IPropertySymbol property in type.GetMembers().OfType<IPropertySymbol>())
                {
                    // Skip explicit interface implementations (they may use different types for compatibility).
                    if (property.ExplicitInterfaceImplementations.Length > 0)
                    {
                        continue;
                    }

                    bool hasSetter = property.SetMethod is not null;
                    bool isInitOnly = property.SetMethod?.IsInitOnly == true;
                    bool isObsolete = IsObsolete(property);
                    bool hasRequired = HasRequiredMember(property);
                    bool isCollection = IsCollectionType(property.Type);
                    bool isImmutableCollection = IsImmutableCollectionInterface(property.Type);
                    bool isPrimaryCtorProperty = primaryCtorParams.Contains(property.Name);
                    properties.Add(new PropertyMetadata
                    {
                        DeclaringType = declaringType,
                        Name = property.Name,
                        HasSetter = hasSetter,
                        IsInitOnly = isInitOnly,
                        IsObsolete = isObsolete,
                        HasRequiredMemberAttribute = hasRequired,
                        IsCollection = isCollection,
                        IsImmutableCollection = isImmutableCollection,
                        IsPrimaryConstructorProperty = isPrimaryCtorProperty
                    });
                }
            }
        }
    }

    private static HashSet<string> GetPrimaryConstructorParameterNames(INamedTypeSymbol type)
    {
        HashSet<string> names = new(StringComparer.Ordinal);

        // For records, find the primary constructor (the one with parameters matching synthesized properties)
        // When analyzing metadata (referenced assemblies), DeclaringSyntaxReferences is empty,
        // so we identify primary constructor by finding a constructor whose parameters all have
        // corresponding auto-generated properties with init-only setters.
        foreach (IMethodSymbol ctor in type.InstanceConstructors)
        {
            // Skip the copy constructor (single parameter of the same type)
            if (ctor.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(ctor.Parameters[0].Type, type))
            {
                continue;
            }

            // Skip parameterless constructors
            if (ctor.Parameters.Length == 0)
            {
                continue;
            }

            // Check if all parameters have matching properties (characteristic of primary constructor)
            bool allParamsHaveProperties = true;
            List<string> candidateNames = [];

            foreach (IParameterSymbol param in ctor.Parameters)
            {
                IPropertySymbol? matchingProperty = type.GetMembers(param.Name)
                    .OfType<IPropertySymbol>()
                    .FirstOrDefault(p => !p.IsStatic && SymbolEqualityComparer.Default.Equals(p.Type, param.Type));

                if (matchingProperty is not null)
                {
                    candidateNames.Add(param.Name);
                }
                else
                {
                    allParamsHaveProperties = false;
                    break;
                }
            }

            // If all parameters have matching properties, this is likely the primary constructor
            if (allParamsHaveProperties && candidateNames.Count > 0)
            {
                foreach (string name in candidateNames)
                {
                    names.Add(name);
                }
                break; // Found the primary constructor
            }
        }

        return names;
    }

    private static bool IsObsolete(IPropertySymbol property)
    {
        foreach (AttributeData attribute in property.GetAttributes())
        {
            INamedTypeSymbol? attrClass = attribute.AttributeClass;
            if (attrClass is null)
            {
                continue;
            }
            if (attrClass.Name == "ObsoleteAttribute")
            {
                return true;
            }
        }
        return false;
    }

    private static bool HasRequiredMember(IPropertySymbol property)
    {
        // Prefer Roslyn's IsRequired when available.
        bool isRequiredFlag = false;
        try
        {
            if (property.IsRequired)
            {
                return true;
            }
        }
        catch
        {
            // Older Roslyn may throw; ignore and fall back.
            isRequiredFlag = false;
        }

        foreach (AttributeData attribute in property.GetAttributes())
        {
            INamedTypeSymbol? attrClass = attribute.AttributeClass;
            if (attrClass is null)
            {
                continue;
            }
            string fullName = attrClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fullName == "global::System.Runtime.CompilerServices.RequiredMemberAttribute" || attrClass.Name == "RequiredMemberAttribute")
            {
                return true;
            }
        }
        return isRequiredFlag;
    }

    private static void EmitPlaceholder(SourceProductionContext context)
    {
        context.AddSource("AssemblyFixture.DtPropertyMetadata.g.cs",
            """
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Collections.Generic;
            namespace GuildWars2.Tests.Common;
            public partial class AssemblyFixture
            {
                public readonly struct DtProperty
                {
                    public DtProperty(string declaringType, string name, bool hasSetter, bool isInitOnly, bool isObsolete, bool hasRequiredMemberAttribute, bool isCollection, bool isImmutableCollection, bool isPrimaryConstructorProperty)
                    {
                        DeclaringType = declaringType;
                        Name = name;
                        HasSetter = hasSetter;
                        IsInitOnly = isInitOnly;
                        IsObsolete = isObsolete;
                        HasRequiredMemberAttribute = hasRequiredMemberAttribute;
                        IsCollection = isCollection;
                        IsImmutableCollection = isImmutableCollection;
                        IsPrimaryConstructorProperty = isPrimaryConstructorProperty;
                    }
                    public string DeclaringType { get; }
                    public string Name { get; }
                    public bool HasSetter { get; }
                    public bool IsInitOnly { get; }
                    public bool IsObsolete { get; }
                    public bool HasRequiredMemberAttribute { get; }
                    public bool IsCollection { get; }
                    public bool IsImmutableCollection { get; }
                    public bool IsPrimaryConstructorProperty { get; }
                }
                public IEnumerable<DtProperty> DataTransferObjectProperties { get; } = new DtProperty[] { };
            }
            """
        );
    }

    private struct PropertyMetadata
    {
        public string DeclaringType { get; set; }
        public string Name { get; set; }
        public bool HasSetter { get; set; }
        public bool IsInitOnly { get; set; }
        public bool IsObsolete { get; set; }
        public bool HasRequiredMemberAttribute { get; set; }
        public bool IsCollection { get; set; }
        public bool IsImmutableCollection { get; set; }
        public bool IsPrimaryConstructorProperty { get; set; }
    }

    private static bool IsCollectionType(ITypeSymbol type)
    {
        // Check if the type implements IEnumerable<T> (but exclude string)
        if (type.SpecialType == SpecialType.System_String)
        {
            return false;
        }

        foreach (INamedTypeSymbol iface in type.AllInterfaces)
        {
            if (iface.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
            {
                return true;
            }
        }

        // Also check if the type itself is IEnumerable<T>
        if (type is INamedTypeSymbol namedType && namedType.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
        {
            return true;
        }

        return false;
    }

    private static bool IsImmutableCollectionInterface(ITypeSymbol type)
    {
        // Check if type is IImmutableValueList<T>, IImmutableValueSet<T>, IImmutableValueDictionary<TKey, TValue>, IImmutableValueArray<T>
        if (type is INamedTypeSymbol namedType)
        {
            string name = namedType.OriginalDefinition.ToDisplayString();
            return name.StartsWith("GuildWars2.Collections.IImmutableValue", StringComparison.Ordinal);
        }

        return false;
    }
}
