using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

namespace GuildWars2.Tests.Generators;

// Generates a list of JsonElement -> DTO reader extension methods so tests avoid unsupported reflection under Native AOT.
// The original test used Type.GetMethods which may require metadata not preserved when trimmed. This generator
// captures the required metadata at compile time and exposes it via AssemblyFixture.JsonElementReaderMethods.
[Generator]
internal sealed class JsonElementReaderMethodGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterSourceOutput(context.CompilationProvider, static (spc, compilation) => Execute(compilation, spc));
    }

    private static void Execute(Compilation compilation, SourceProductionContext context)
    {
        IAssemblySymbol? sdk = compilation.SourceModule.ReferencedAssemblySymbols.FirstOrDefault(a => string.Equals(a.Name, "GW2SDK", StringComparison.Ordinal));
        if (sdk is null)
        {
            EmitPlaceholder(context);
            return;
        }

        // Collect DTO types (classes annotated with DataTransferObjectAttribute) for filtering.
        HashSet<INamedTypeSymbol> dtoTypes = new(SymbolEqualityComparer.Default);
        EnumerateDtoTypes(sdk.GlobalNamespace, dtoTypes);

        List<ReaderMethod> readerMethods = [];
        EnumerateReaderMethods(sdk.GlobalNamespace, dtoTypes, readerMethods);

        StringBuilder builder = new();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("namespace GuildWars2.Tests.Common;");
        builder.AppendLine();
        builder.AppendLine("public partial class AssemblyFixture");
        builder.AppendLine("{");
        builder.AppendLine("    public readonly struct JsonReaderMethod");
        builder.AppendLine("    {");
        builder.AppendLine("        public JsonReaderMethod(string name, Type returnType, Type declaringType, Type firstParameterType, bool isExtensionMethod, bool isDeclaringTypeNotPublic, string @namespace)");
        builder.AppendLine("        {");
        builder.AppendLine("            Name = name; ReturnType = returnType; DeclaringType = declaringType; FirstParameterType = firstParameterType; IsExtensionMethod = isExtensionMethod; IsDeclaringTypeNotPublic = isDeclaringTypeNotPublic; Namespace = @namespace;");
        builder.AppendLine("        }");
        builder.AppendLine("        public string Name { get; }");
        builder.AppendLine("        public Type ReturnType { get; }");
        builder.AppendLine("        public Type DeclaringType { get; }");
        builder.AppendLine("        public Type FirstParameterType { get; }");
        builder.AppendLine("        public bool IsExtensionMethod { get; }");
        builder.AppendLine("        public bool IsDeclaringTypeNotPublic { get; }");
        builder.AppendLine("        public string Namespace { get; }");
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    public IEnumerable<JsonReaderMethod> JsonElementReaderMethods { get; } = new JsonReaderMethod[]");
        builder.AppendLine("    {");
        bool first = true;
        foreach (ReaderMethod method in readerMethods.OrderBy(m => m.ReturnType).ThenBy(m => m.Name))
        {
            if (!first)
            {
                builder.AppendLine(",");
            }
            builder.Append("        new JsonReaderMethod(\"" + method.Name + "\", typeof(" + method.ReturnType + "), typeof(" + method.DeclaringType + "), typeof(global::System.Text.Json.JsonElement), isExtensionMethod: true, isDeclaringTypeNotPublic: " + (method.IsDeclaringTypeNotPublic ? "true" : "false") + ", @namespace: \"" + method.Namespace + "\")");
            first = false;
        }
        builder.AppendLine();
        builder.AppendLine("    }; ");
        builder.AppendLine("}");

        context.AddSource("AssemblyFixture.JsonElementReaderMethods.g.cs", builder.ToString());
    }

    private static void EmitPlaceholder(SourceProductionContext context)
    {
        context.AddSource("AssemblyFixture.JsonElementReaderMethods.g.cs",
            """
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Collections.Generic;
            namespace GuildWars2.Tests.Common;
            public partial class AssemblyFixture
            {
                public readonly struct JsonReaderMethod
                {
                    public JsonReaderMethod(string name, Type returnType, Type declaringType, Type firstParameterType, bool isExtensionMethod, bool isDeclaringTypeNotPublic, string @namespace)
                    {
                        Name = name; ReturnType = returnType; DeclaringType = declaringType; FirstParameterType = firstParameterType; IsExtensionMethod = isExtensionMethod; IsDeclaringTypeNotPublic = isDeclaringTypeNotPublic; Namespace = @namespace;
                    }
                    public string Name { get; }
                    public Type ReturnType { get; }
                    public Type DeclaringType { get; }
                    public Type FirstParameterType { get; }
                    public bool IsExtensionMethod { get; }
                    public bool IsDeclaringTypeNotPublic { get; }
                    public string Namespace { get; }
                }
                public IEnumerable<JsonReaderMethod> JsonElementReaderMethods { get; } = new JsonReaderMethod[] { };
            }
            """);
    }

    private static void EnumerateDtoTypes(INamespaceSymbol scope, HashSet<INamedTypeSymbol> matches)
    {
        foreach (ISymbol member in scope.GetMembers())
        {
            if (member is INamespaceSymbol ns)
            {
                EnumerateDtoTypes(ns, matches);
            }
            else if (member is INamedTypeSymbol type && type.TypeKind == TypeKind.Class)
            {
                foreach (AttributeData attribute in type.GetAttributes())
                {
                    if (string.Equals(attribute.AttributeClass?.Name, "DataTransferObjectAttribute", StringComparison.Ordinal))
                    {
                        if (type.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal)
                        {
                            matches.Add(type);
                        }
                        break;
                    }
                }
            }
        }
    }

    private static void EnumerateReaderMethods(INamespaceSymbol scope, HashSet<INamedTypeSymbol> dtoTypes, List<ReaderMethod> methods)
    {
        foreach (ISymbol member in scope.GetMembers())
        {
            if (member is INamespaceSymbol ns)
            {
                EnumerateReaderMethods(ns, dtoTypes, methods);
            }
            else if (member is INamedTypeSymbol type && type.TypeKind == TypeKind.Class)
            {
                if (!type.Name.EndsWith("Json", StringComparison.Ordinal))
                {
                    continue;
                }

                foreach (ISymbol symbol in type.GetMembers())
                {
                    if (symbol is IMethodSymbol method && method.IsStatic && method.IsExtensionMethod && method.DeclaredAccessibility == Accessibility.Public)
                    {
                        if (method.Parameters.Length == 0)
                        {
                            continue; // Not an extension shape we expect.
                        }
                        IParameterSymbol first = method.Parameters[0];
                        if (!string.Equals(first.Type.Name, "JsonElement", StringComparison.Ordinal))
                        {
                            continue;
                        }
                        // Only capture methods whose return type is a DTO type.
                        if (method.ReturnType is INamedTypeSymbol namedReturn && dtoTypes.Contains(namedReturn))
                        {
                            methods.Add(new ReaderMethod
                            {
                                Name = method.Name,
                                DeclaringType = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty),
                                ReturnType = namedReturn.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty),
                                IsDeclaringTypeNotPublic = type.DeclaredAccessibility == Accessibility.Internal,
                                Namespace = type.ContainingNamespace.ToDisplayString()
                            });
                        }
                    }
                }
            }
        }
    }

    private struct ReaderMethod
    {
        public string Name { get; set; }
        public string DeclaringType { get; set; }
        public string ReturnType { get; set; }
        public bool IsDeclaringTypeNotPublic { get; set; }
        public string Namespace { get; set; }
    }
}
